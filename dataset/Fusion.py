import json
import os
import torch
from torch.utils.data.dataset import Dataset
import random
import numpy as np
from torchvision import transforms
from collections import Counter
from tqdm import tqdm


class Fusion(Dataset):
    def __init__(self, cfg, mode='train'):
        assert mode in ['train', 'val', 'test']
        way, shot, query = cfg.TASK.N_WAY, cfg.TASK.N_SHOT, cfg.TASK.N_QUERY
        base_path = cfg.DATASET.BASE_PATH

        img_data_path = f"{base_path}/{mode}/img.pt"  # TODO img_new.pt
        api_data_path = f"{base_path}/{mode}/api.pt"

        # if mode == "val":
        #     img_data_path = "/home/scusw1/malware/datas/LargePE/fusion/img_data.pt"
        #     api_data_path = "/home/scusw1/malware/datas/LargePE/fusion/api_data.pt"
        #     base_path = '/home/scusw1/malware/datas/LargePE/img_data/'

        self.img_data = torch.load(img_data_path)  # [1740, 1, 256, 256]
        self.api_data = torch.load(api_data_path)  # [1740, 300]

        self.N = shot + query  # num of samples per class

        self.mode = mode
        self.shot, self.query, self.way = shot, query, way

        # img_data augmentation
        self.transform = transforms.Compose([
            transforms.RandomCrop(224),
            # transforms.Resize(256, antialias=True),
            transforms.RandomHorizontalFlip(),
            # transforms.RandomVerticalFlip(),
            # RandomErasing,
            # transforms.ColorJitter(brightness=0.2, contrast=0.2),
        ])

        self.support_labels = torch.LongTensor([clz for clz in range(way)
                                       for _ in range(shot)]).cuda()
        self.query_labels = torch.LongTensor([clz for clz in range(way)
                                     for _ in range(query)]).cuda()

        assert len(self.img_data) % self.N == 0, f"num of samples of each class should be {self.N}!"
        assert len(self.img_data) == len(self.api_data), "img_data and api_data should have the same length!"
        num_class = len(self.img_data) // self.N
        self.num_class = num_class

        self.img_data = self.img_data.view(num_class, self.N, *self.img_data.size()[1:])  # [87, 20, 256, 256]
        self.api_data = self.api_data.view(num_class, self.N, *self.api_data.size()[1:])  # [87, 20, 300]
        self.img_data = self.img_data.cuda()
        self.api_data = self.api_data.cuda()

        label_path = f"{base_path}/{mode}/label.pt"
        if os.path.exists(label_path):
            self.labels = torch.load(label_path).cuda()
        else:
            self.labels = torch.LongTensor([clz for clz in range(num_class) for _ in range(self.N)]).cuda()

        self.labels = Counter(self.labels.tolist())

    def __getitem__(self, item):
        # select way classes from num_class
        classes = random.sample(range(self.num_class), self.way)
        # map label to 0 - way-1
        class_map = {classes[i]: i for i in range(self.way)}
        if self.mode == 'test':
            self.current_classes = classes
        support_img, support_api, query_img, query_api = [], [], [], []
        
        # groups = [np.random.permutation(self.N) for _ in range(self.way)]
        groups = [np.random.permutation(self.labels[clz]) for clz in classes]
        img_data = self.img_data[classes]  # [way, N, 1, 256, 256]
        api_data = self.api_data[classes]  # [way, N, 300]

        for i in range(self.way):
            clz, group = class_map[classes[i]], groups[i]
            support_set_idx, query_set_idx = group[:self.shot], group[self.shot:]
            _support_img = img_data[clz][support_set_idx]
            _query_img = img_data[clz][query_set_idx]
            _support_api = api_data[clz][support_set_idx]
            _query_api = api_data[clz][query_set_idx]

            support_img.append(_support_img)
            support_api.append(_support_api)
            query_img.append(_query_img)
            query_api.append(_query_api)

        support_img = torch.cat(support_img, dim=0)  # [25, 1, 256, 256]
        support_api = torch.cat(support_api, dim=0)
        query_img = torch.cat(query_img, dim=0)
        query_api = torch.cat(query_api, dim=0)

        support_labels = self.support_labels
        # query_labels = self.query_labels
        query_labels = torch.LongTensor([clz for clz in range(self.way)
                                       for _ in range(groups[clz].shape[0] - self.shot)]).cuda()

        # data augmentation
        if self.mode == 'train':
            support_img = self.transform(support_img)
            query_img = self.transform(query_img)

        # return support_img, support_labels, query_img, query_labels
        return {
            "support_img": support_img,
            "support_api": support_api,
            "query_img": query_img,
            "query_api": query_api,
            "support_labels": support_labels,
            "query_labels": query_labels
        }

    def __len__(self):
        return 1


if __name__ == '__main__':
    import sys
    sys.path.insert(0, '/home/scusw1/malware/fusion/')
    from utils import load_cfg
    cfg = load_cfg()
    dataset = Fusion(cfg, mode='train')
    print(dataset[0].keys())
    for k, v in dataset[0].items():
        print(k, v.size())